#Updates netdot database from version 0.9 to version 1.0

use warnings;
use strict;
use lib "../lib";
use DBUTIL;
use Netdot;
use Netdot::Model;
use Netdot::Meta;
use Data::Dumper;

my %CONFIG;
$CONFIG{debug} = 1;
$CONFIG{CONFIG_DIR} = "../etc";
$CONFIG{SCHEMA_FILE}  = "$CONFIG{CONFIG_DIR}/netdot.meta";
$CONFIG{DEFAULT_DATA} = "$CONFIG{CONFIG_DIR}/default_data";

my $netdot_config = Netdot::Config->new(config_dir => $CONFIG{CONFIG_DIR});

my $dbh = &dbconnect();
my @statements = ();


if ($netdot_config->get('DB_TYPE') eq "mysql") {
    @statements = (
	"CREATE TABLE `asset` (
            `custom_serial` varchar(255),
            `date_purchased` date,
            `description` varchar(255),
            `id` bigint NOT NULL auto_increment,
            `info` text,
            `inventory_number` varchar(255),
            `maint_contract` bigint,
            `maint_from` date,
            `maint_until` date,
            `physaddr` bigint,
            `po_number` varchar(255),
            `product_id` bigint,
            `reserved_for` varchar(255),
            `serial_number` varchar(255),
            UNIQUE INDEX asset1 (`physaddr`),
            UNIQUE INDEX asset2 (`product_id`, `serial_number`),
            INDEX Asset3 (`serial_number`),
            INDEX Asset4 (`inventory_number`),
            INDEX Asset5 (`po_number`),
            INDEX (`maint_contract`),
            PRIMARY KEY (`id`)
         ) ENGINE=InnoDB;",
        );
} elsif ($netdot_config->get('DB_TYPE') eq "Pg") {
    my $u = $netdot_config->get('DB_NETDOT_USER');
    @statements = (
	"CREATE TABLE asset (
             custom_serial character varying(255),
             date_purchased date,
             description character varying(255),
             id serial NOT NULL,
             info text,
             inventory_number character varying(255),
             maint_contract bigint,
             maint_from date,
             maint_until date,
             physaddr bigint,
             po_number character varying(255),
             reserved_for character varying(255),
             product_id bigint,
             serial_number character varying(255)
        );",
	"CREATE INDEX Asset3 on asset (\"product_id\");",
	"CREATE INDEX Asset4 on asset (\"inventory_number\");",
        "CREATE INDEX Asset5 on asset (\"po_number\");",
	"GRANT ALL ON asset TO $u;",
        );
}

# Add new Product type for device modules
push @statements, "INSERT INTO producttype (name) VALUES ('Module');";

&processdata(\@statements);

# Store assets to be inserted, keyed by serial number
my %assets;

# Grab devices with serial number and product
my $sndevs = $dbh->selectall_arrayref('SELECT serialnumber,custom_serial,physaddr,
                                              inventorynumber,maint_contract,maint_from,
                                              maint_until,product 
                                        FROM device
		                        WHERE serialnumber IS NOT NULL
                                          AND serialnumber != "" 
                                          AND product IS NOT NULL
                                          AND product != "" ');
foreach my $row ( @$sndevs ){
    my $sn = $row->[0];
    $sn =~ s/^\s+|\s+$//g;
    next unless $sn;
    # Convert foreign keys from 0 to undef
    $row->[2] = undef if $row->[2] == 0;
    $row->[4] = undef if $row->[4] == 0;
    $row->[7] = undef if $row->[7] == 0;
    my $i = 1;
    foreach my $v (qw/cs ph in mc mf mu pr/){
	$assets{sn}{$sn}{$v} = $row->[$i];
	$i++;
    }
}

########################################################
# Grab devicemodules with serial number and model.
# Migrating stuff from modules takes a bit more work
# because the new products need to be created
my $snmods = $dbh->selectall_arrayref('SELECT dm.serialnumber,dm.inventorynumber,
                                              dm.maint_contract,dm.maint_from,
                                              dm.maint_until,dm.model,e.id
                                         FROM devicemodule dm, device d, product p, entity e
                                        WHERE dm.device=d.id AND d.product=p.id 
                                          AND p.manufacturer=e.id
		                          AND dm.serialnumber IS NOT NULL
                                          AND dm.model IS NOT NULL');

my %products;
foreach my $row ( @$snmods ){
    my $sn = $row->[0];
    $sn =~ s/^\s+|\s+$//g;
    next unless $sn;
    my $model = $row->[5];
    $model =~ s/^\s+|\s+$//g;
    my $mf = $row->[6];
    next unless $model && $mf;
    my $i = 1;
    foreach my $v (qw/in mc mf mu/){
	$assets{sn}{$sn}{$v} = $row->[$i];
	$i++;
    }
    # Associate model/mf with each S/N
    push(@{$products{$mf}{$model}}, $sn);
}

# Insert products

# Get the Module product type id
my @ptrow = $dbh->selectrow_array('SELECT id FROM producttype WHERE name="Module"');
my $ptype = $ptrow[0];

my $np = $dbh->prepare('INSERT INTO product (name, manufacturer,type) VALUES(?,?,?)');
foreach my $mf ( keys %products ){
    foreach my $model ( keys %{$products{$mf}} ){
	next if ($model =~ /Fill in/io );
	eval {
	    $np->execute($model, $mf, $ptype);
	};
	if ( my $e = $@ ){
	    if ( $e =~ /duplicate/i ){
		next;
	    }else{
		die $e;
	    }
	}
	print "DEBUG: Inserted product ($mf, $model)\n" if $CONFIG{debug};
    }
}
# Get product IDs
print "DEBUG: Retrieving all products from DB\n" if $CONFIG{debug};
my $prodq = $dbh->selectall_arrayref('SELECT id,name,manufacturer FROM product');
my %allprods;
foreach my $row ( @$prodq ){
    my($id,$name,$mf) = @$row;
    $allprods{$mf}{$name} = $id;
}

# Complete the Asset hash with product IDs
foreach my $mf ( keys %products ){
    foreach my $model ( keys %{$products{$mf}} ){
	my $product_id;
	if ( exists $allprods{$mf}{$model} ){
	    $product_id = $allprods{$mf}{$model};
	    print "DEBUG: Product ($mf,$model) found: $product_id\n" if $CONFIG{debug};
	    foreach my $sn ( @{$products{$mf}{$model}} ){
		print "DEBUG: Assigning prod ID: $product_id to module S/N: $sn\n" if $CONFIG{debug};
		$assets{sn}{$sn}{pr} = $product_id;
	    }
	}
    }
}

# Grab devices with base MAC and product but no serial number
my $macdevs = $dbh->selectall_arrayref('SELECT physaddr,custom_serial,inventorynumber,
                                               maint_contract,maint_from,maint_until,product 
                                          FROM device
		                         WHERE physaddr is not NULL
                                           AND physaddr != 0 
                                           AND product IS NOT NULL
                                           AND product != "" 
                                           AND (serialnumber IS NULL
                                             OR serialnumber = "")');
foreach my $row ( @$macdevs ){
    my $ph = $row->[0];
    $ph =~ s/^\s+|\s+$//g;
    next unless $ph;
    # Convert foreign keys from 0 to undef
    $row->[3] = undef if $row->[3] == 0;
    $row->[6] = undef if $row->[6] == 0;
    my $i = 1;
    foreach my $v (qw/cs in mc mf mu pr/){
	$assets{ph}{$ph}{$v} = $row->[$i];
	$i++;
    }
}

# Create asset records with information from devices and modules
my $ia = $dbh->prepare('INSERT INTO asset (serial_number,custom_serial,physaddr,
                                           inventory_number,maint_contract,
                                           maint_from,maint_until,product_id)
                                           VALUES (?,?,?,?,?,?,?,?)');
my %newassets;
foreach my $sn ( keys %{$assets{sn}} ){
    my %vals = %{$assets{sn}{$sn}};
    my ($cs,$ph,$in,$mc,$mf,$mu,$pr) = @vals{'cs','ph','in','mc','mf','mu','pr'};
    $ia->execute($sn,$cs,$ph,$in,$mc,$mf,$mu,$pr);
    print "DEBUG: Created asset: S/N: $sn, product: $pr\n" if $CONFIG{debug};
    $newassets{$ph} = 1 if $ph;
}

foreach my $ph ( keys %{$assets{ph}} ){
    my %vals = %{$assets{ph}{$ph}};
    my ($cs,$in,$mc,$mf,$mu,$pr) = @vals{'cs','in','mc','mf','mu','pr'};
    next if ( exists $newassets{$ph} );
    my $sn = undef;
    $ia->execute($sn,$cs,$ph,$in,$mc,$mf,$mu,$pr);
    print "DEBUG: Created asset: Mac: $ph, product: $pr\n" if $CONFIG{debug};
}

# Grab hostaudit data before conversion
my $haudits = $dbh->selectall_arrayref('SELECT          ha.id,zone.name,dhcpscope.name  
                                        FROM            hostaudit ha 
                                        LEFT OUTER JOIN zone ON ha.zone=zone.id 
                                        LEFT OUTER JOIN dhcpscope ON ha.scope=dhcpscope.id');
my %haudit;
foreach my $row ( @$haudits ){
    my ($id, $zone, $scope) = @$row;
    $haudit{$id}{zone}  = $zone;
    $haudit{$id}{scope} = $scope;
}

my @statements;

# There are some discrepancies between a schema created in 0.9 and the 
# schema *upgraded* to 0.9
my $idx = $dbh->selectall_arrayref("
  SELECT COUNT(1) cnt
  FROM    INFORMATION_SCHEMA.STATISTICS
  WHERE   table_name = 'device'
  AND     index_name = 'Device12'
");
if ( $idx && scalar(@$idx) ){
    @statements=('ALTER TABLE device DROP INDEX Device12;');
}

if ($netdot_config->get('DB_TYPE') eq "mysql") {
    my $dbname = $netdot_config->get('DB_DATABASE');
    
    push @statements, (
	"ALTER DATABASE $dbname CHARACTER SET utf8 COLLATE utf8_general_ci;",
	"ALTER TABLE device ADD COLUMN asset_id bigint;",
	"ALTER TABLE device ADD COLUMN extension integer;",
	"ALTER TABLE device_history ADD COLUMN asset_id bigint;",
	"ALTER TABLE device_history ADD COLUMN extension integer;",
	
	"UPDATE device,asset SET device.asset_id=asset.id 
              WHERE (asset.serial_number=device.serialnumber
                AND asset.product_id=device.product)
                OR  asset.physaddr=device.physaddr;",

	"ALTER TABLE devicemodule ADD COLUMN asset_id bigint;",

	"UPDATE devicemodule,asset SET devicemodule.asset_id=asset.id 
              WHERE asset.serial_number=devicemodule.serialnumber;",

	"ALTER TABLE device DROP COLUMN serialnumber;",
	"ALTER TABLE device DROP COLUMN inventorynumber;",
	"ALTER TABLE device DROP COLUMN maint_contract;",
	"ALTER TABLE device DROP COLUMN maint_from;",
	"ALTER TABLE device DROP COLUMN maint_until;",
	"ALTER TABLE device DROP COLUMN custom_serial;",
	"ALTER TABLE device DROP COLUMN physaddr;",
	"ALTER TABLE device DROP COLUMN product;",
	"ALTER TABLE device ADD INDEX Device13 (extension);",
	"ALTER TABLE device_history DROP COLUMN serialnumber;",
	"ALTER TABLE device_history DROP COLUMN inventorynumber;",
	"ALTER TABLE device_history DROP COLUMN maint_contract;",
	"ALTER TABLE device_history DROP COLUMN maint_from;",
	"ALTER TABLE device_history DROP COLUMN maint_until;",
	"ALTER TABLE device_history DROP COLUMN custom_serial;",
	"ALTER TABLE device_history DROP COLUMN physaddr;",
	"ALTER TABLE device_history DROP COLUMN product;",
	"ALTER TABLE devicemodule DROP COLUMN serialnumber;",
	"ALTER TABLE devicemodule DROP COLUMN inventorynumber;",
	"ALTER TABLE devicemodule DROP COLUMN maint_contract;",
	"ALTER TABLE devicemodule DROP COLUMN maint_from;",
	"ALTER TABLE devicemodule DROP COLUMN maint_until;",
	"ALTER TABLE dhcpscope ADD COLUMN active tinyint(1) NOT NULL;",
	"UPDATE dhcpscope SET active=1;",
	"ALTER TABLE dhcpscope ADD COLUMN duid varchar(255);",
	"ALTER TABLE dhcpscope ADD COLUMN version integer;",
	"ALTER TABLE entity ADD COLUMN config_type varchar(255);",
	"ALTER TABLE entity_history ADD COLUMN config_type varchar(255);",
	"ALTER TABLE product ADD COLUMN part_number varchar(255);",
	"ALTER TABLE product ADD COLUMN config_type varchar(255);",
	"ALTER TABLE product_history ADD COLUMN part_number varchar(255);",
	"ALTER TABLE product_history ADD COLUMN config_type varchar(255);",
	"ALTER TABLE interface MODIFY COLUMN speed bigint;",
	"ALTER TABLE interface_history MODIFY COLUMN speed bigint;",
	"ALTER TABLE datacache MODIFY COLUMN tstamp bigint NOT NULL;",
	"DELETE FROM datacache;",
	"ALTER TABLE device ADD COLUMN snmp_conn_attempts integer;",
	"ALTER TABLE device ADD COLUMN snmp_down tinyint(1) NOT NULL;",
	"ALTER TABLE device_history ADD COLUMN snmp_conn_attempts integer;",
	"ALTER TABLE device_history ADD COLUMN snmp_down tinyint(1) NOT NULL;",
	"ALTER TABLE rr ADD COLUMN created timestamp;",
	"ALTER TABLE rr ADD COLUMN modified timestamp;",
	"ALTER TABLE rr ADD INDEX RR4 (`created`);",
	"ALTER TABLE rr ADD INDEX RR5 (`modified`);",
	"ALTER TABLE zone ADD COLUMN include blob;",
	"ALTER TABLE rrloc MODIFY COLUMN latitude bigint NOT NULL;",
	"ALTER TABLE rrloc MODIFY COLUMN longitude bigint NOT NULL;",
	"ALTER TABLE rrloc MODIFY COLUMN altitude bigint NOT NULL;",
	"ALTER TABLE zone MODIFY COLUMN minimum bigint NOT NULL;",
	"ALTER TABLE zone MODIFY COLUMN serial bigint NOT NULL;",
	"ALTER TABLE bgppeering ADD COLUMN authkey varchar(255);",
	"ALTER TABLE bgppeering ADD COLUMN info text;",
	"ALTER TABLE bgppeering ADD COLUMN max_v4_prefixes integer NOT NULL;",
	"ALTER TABLE bgppeering ADD COLUMN max_v6_prefixes integer NOT NULL;",
	"ALTER TABLE hostaudit MODIFY COLUMN zone varchar(255);",
	"ALTER TABLE hostaudit MODIFY COLUMN scope varchar(255);",
	"ALTER TABLE hostaudit CHANGE COLUMN user username varchar(255);",
	"ALTER TABLE dhcpscope MODIFY COLUMN text text;",
	"ALTER TABLE dhcpscope MODIFY COLUMN export_file varchar(255);",
	"ALTER TABLE dhcpscope MODIFY COLUMN failover_peer varchar(128);",
	"ALTER TABLE zone MODIFY COLUMN include text;",
	"ALTER TABLE savedqueries MODIFY COLUMN querytext text;",
	"ALTER TABLE accessright MODIFY COLUMN object_id bigint NOT NULL;",
	"ALTER TABLE site ADD COLUMN gsf integer;",
	"ALTER TABLE site_history ADD COLUMN gsf integer;",
	
	# FK Indexes
	"ALTER TABLE backbonecable_history ADD KEY (owner);",
	"ALTER TABLE backbonecable_history ADD KEY (start_closet);",
	"ALTER TABLE backbonecable_history ADD KEY (end_closet);",
	"ALTER TABLE backbonecable_history ADD KEY (type);",
	"ALTER TABLE backbonecable ADD KEY (owner);",
	"ALTER TABLE backbonecable ADD KEY (type);",
	"ALTER TABLE cablestrand ADD KEY (fiber_type);",
	"ALTER TABLE cablestrand ADD KEY (status);",
	"ALTER TABLE cablestrand ADD KEY (cable);",
	"ALTER TABLE cablestrand ADD KEY (circuit_id);",
	"ALTER TABLE circuit ADD KEY (status);",
	"ALTER TABLE circuit ADD KEY (type);",
	"ALTER TABLE circuit_history ADD KEY (status);",
	"ALTER TABLE circuit_history ADD KEY (type);",
	"ALTER TABLE circuit_history ADD KEY (linkid);",
	"ALTER TABLE circuit_history ADD KEY (vendor);",
	"ALTER TABLE contact ADD KEY (notify_email);",
	"ALTER TABLE contact ADD KEY (notify_pager);",
	"ALTER TABLE contact ADD KEY (notify_voice);",
	"ALTER TABLE contact ADD KEY (person);",
	"ALTER TABLE contact_history ADD KEY (notify_email);",
	"ALTER TABLE contact_history ADD KEY (notify_pager);",
	"ALTER TABLE contact_history ADD KEY (notify_voice);",
	"ALTER TABLE contact_history ADD KEY (person);",
	"ALTER TABLE contact_history ADD KEY (contactlist);",
	"ALTER TABLE contact_history ADD KEY (contacttype);",
	"ALTER TABLE device ADD KEY (monitorstatus);",
	"ALTER TABLE device ADD KEY (room);",
	"ALTER TABLE device ADD KEY (site);",
	"ALTER TABLE device ADD KEY (snmp_target);",
	"ALTER TABLE device ADD UNIQUE KEY device2 (asset_id);",
	"ALTER TABLE device DROP KEY Device4;",
	"ALTER TABLE device ADD KEY Device3 (used_by);",
	"ALTER TABLE device DROP KEY Device6;",
	"ALTER TABLE device ADD KEY Device4 (owner);",
	"ALTER TABLE device DROP KEY Device7;",
	"ALTER TABLE device ADD KEY Device5 (os);",
	"ALTER TABLE device DROP KEY Device8;",
	"ALTER TABLE device ADD KEY Device6 (sysname);",
	"ALTER TABLE device DROP KEY Device9;",
	"ALTER TABLE device ADD KEY Device7 (down_from);",
	"ALTER TABLE device DROP KEY Device10;",
	"ALTER TABLE device ADD KEY Device8 (down_until);",
	"ALTER TABLE device DROP KEY Device13;",
	"ALTER TABLE device ADD KEY Device9 (extension);",
	"ALTER TABLE device_history ADD KEY (asset_id);",
	"ALTER TABLE device_history ADD KEY (monitorstatus);",
	"ALTER TABLE device_history ADD KEY (name);",
	"ALTER TABLE device_history ADD KEY (owner);",
	"ALTER TABLE device_history ADD KEY (room);",
	"ALTER TABLE device_history ADD KEY (site);",
	"ALTER TABLE device_history ADD KEY (used_by);",
	"ALTER TABLE device_history ADD KEY (snmp_target);",
	"ALTER TABLE devicemodule ADD KEY (asset_id);",
	"ALTER TABLE dhcpscope ADD KEY (container);",
	"ALTER TABLE entity ADD KEY (availability);",
	"ALTER TABLE entity ADD KEY (contactlist);",
	"ALTER TABLE entity DROP KEY Entity2;",
	"UPDATE entity set oid=NULL WHERE oid='';",
	"ALTER TABLE entity ADD UNIQUE KEY entity2 (oid);",
	"ALTER TABLE entity_history ADD KEY (contactlist);",
	"ALTER TABLE entity_history ADD KEY (availability);",
	"ALTER TABLE horizontalcable ADD KEY (contactlist);",
	"ALTER TABLE horizontalcable ADD KEY (type);",
	"ALTER TABLE interface ADD KEY (contactlist);",
	"ALTER TABLE interface ADD KEY (monitorstatus);",
	"ALTER TABLE interface_history ADD KEY (contactlist);",
	"ALTER TABLE interface_history ADD KEY (monitorstatus);",
	"ALTER TABLE interface_history ADD KEY (circuit);",
	"ALTER TABLE interface_history ADD KEY (device);",
	"ALTER TABLE interface_history ADD KEY (jack);",
	"ALTER TABLE interface_history ADD KEY (neighbor);",
	"ALTER TABLE interface_history ADD KEY (physaddr);",
	"ALTER TABLE ipblock ADD KEY (owner);",
	"ALTER TABLE ipblock ADD KEY (used_by);",
	"ALTER TABLE ipservice ADD KEY (contactlist);",
	"ALTER TABLE ipservice ADD KEY (monitorstatus);",
	"ALTER TABLE maintcontract ADD KEY (provider);",
	"ALTER TABLE person ADD KEY (location);",
	"ALTER TABLE person ADD KEY (room);",
	"ALTER TABLE person ADD KEY (user_type);",
	"ALTER TABLE person_history ADD KEY (location);",
	"ALTER TABLE person_history ADD KEY (room);",
	"ALTER TABLE person_history ADD KEY (user_type);",
	"ALTER TABLE person_history ADD KEY (entity);",
	"ALTER TABLE product_history ADD KEY (manufacturer);",
	"ALTER TABLE product_history ADD KEY (type);",
	"ALTER TABLE site ADD KEY (availability);",
	"ALTER TABLE site ADD KEY (contactlist);",
	"ALTER TABLE site_history ADD KEY (availability);",
	"ALTER TABLE site_history ADD KEY (contactlist);",
	"ALTER TABLE sitelink ADD KEY (farend);",
	"ALTER TABLE sitelink ADD KEY (nearend);",
	"ALTER TABLE sitelink ADD KEY (entity);",
	"ALTER TABLE sitelink_history ADD KEY (farend);",
	"ALTER TABLE sitelink_history ADD KEY (nearend);",
	"ALTER TABLE sitelink_history ADD KEY (entity);",
	"ALTER TABLE zone ADD KEY (contactlist);",
	"ALTER TABLE zonealias ADD KEY (zone);",
	
	);
} elsif ($netdot_config->get('DB_TYPE') eq "Pg") {
    @statements = (
	"ALTER TABLE device ADD COLUMN asset_id bigint;",
	"ALTER TABLE device ADD COLUMN extension integer NULL;",
	"ALTER TABLE device_history ADD COLUMN asset_id bigint;",
	"ALTER TABLE device_history ADD COLUMN extension integer NULL;",

	"UPDATE device SET asset_id=asset.id 
               FROM asset 
              WHERE (asset.serial_number=device.serialnumber
                AND asset.product_id=device.product)
                 OR asset.physaddr=device.physaddr;",

	"ALTER TABLE devicemodule ADD COLUMN asset_id bigint;",

	"UPDATE devicemodule SET asset_id=asset.id 
               FROM asset 
              WHERE asset.serial_number=devicemodule.serialnumber;",

	"ALTER TABLE device DROP COLUMN serialnumber;",
	"ALTER TABLE device DROP COLUMN inventorynumber;",
	"ALTER TABLE device DROP COLUMN maint_contract;",
	"ALTER TABLE device DROP COLUMN maint_from;",
	"ALTER TABLE device DROP COLUMN maint_until;",
	"ALTER TABLE device DROP COLUMN custom_serial;",
	"ALTER TABLE device DROP COLUMN physaddr;",
	"ALTER TABLE device DROP COLUMN product;",
	"CREATE INDEX Device13 ON device(extension);",
	"ALTER TABLE device_history DROP COLUMN serialnumber;",
	"ALTER TABLE device_history DROP COLUMN inventorynumber;",
	"ALTER TABLE device_history DROP COLUMN maint_contract;",
	"ALTER TABLE device_history DROP COLUMN maint_from;",
	"ALTER TABLE device_history DROP COLUMN maint_until;",
	"ALTER TABLE device_history DROP COLUMN custom_serial;",
	"ALTER TABLE device_history DROP COLUMN physaddr;",
	"ALTER TABLE device_history DROP COLUMN product;",
	"ALTER TABLE devicemodule DROP COLUMN serialnumber;",
	"ALTER TABLE devicemodule DROP COLUMN inventorynumber;",
	"ALTER TABLE devicemodule DROP COLUMN maint_contract;",
	"ALTER TABLE devicemodule DROP COLUMN maint_from;",
	"ALTER TABLE devicemodule DROP COLUMN maint_until;",
	"ALTER TABLE dhcpscope ADD COLUMN active smallint NOT NULL;",
	"UPDATE dhcpscope SET active=1;",
	"ALTER TABLE dhcpscope ADD COLUMN duid varchar(255);",
	"ALTER TABLE dhcpscope ADD COLUMN version integer;",
	"ALTER TABLE entity ADD COLUMN config_type varchar(255);",
	"ALTER TABLE entity_history ADD COLUMN config_type varchar(255);",
	"ALTER TABLE product ADD COLUMN part_number varchar(255);",
	"ALTER TABLE product ADD COLUMN config_type varchar(255);",
	"ALTER TABLE product_history ADD COLUMN part_number varchar(255);",
	"ALTER TABLE product_history ADD COLUMN config_type varchar(255);", 
	"ALTER TABLE interface ALTER COLUMN speed TYPE bigint;",
	"ALTER TABLE datacache ALTER COLUMN tstamp TYPE bigint NOT NULL;",
	"DELETE FROM datacache;",
	"ALTER TABLE device ADD COLUMN snmp_conn_attempts integer;",
	"ALTER TABLE device ADD COLUMN snmp_down smallint NOT NULL;",
	"ALTER TABLE device_history ADD COLUMN snmp_conn_attempts integer;",
	"ALTER TABLE device_history ADD COLUMN snmp_down smallint NOT NULL;",
	"ALTER TABLE rr ADD COLUMN created timestamp;",
	"ALTER TABLE rr ADD COLUMN modified timestamp;",
	"CREATE INDEX RR4 ON rr(created);",
	"CREATE INDEX RR5 ON rr(modified);",
	"ALTER TABLE zone ADD COLUMN include text;",
	"ALTER TABLE rrloc ALTER COLUMN latitude TYPE bigint;",
	"ALTER TABLE rrloc ALTER COLUMN longitude TYPE bigint;",
	"ALTER TABLE rrloc ALTER COLUMN altitude TYPE bigint;",
	"ALTER TABLE zone ALTER COLUMN minimum TYPE bigint;",
	"ALTER TABLE zone ALTER COLUMN serial TYPE bigint;",
	"ALTER TABLE bgppeering ADD COLUMN authkey varchar(255);",
	"ALTER TABLE bgppeering ADD COLUMN info text;",
	"ALTER TABLE bgppeering ADD COLUMN max_v4_prefixes integer;",
	"ALTER TABLE bgppeering ADD COLUMN max_v6_prefixes integer;",
	"ALTER TABLE hostaudit ALTER COLUMN zone TYPE varchar(255);",
	"ALTER TABLE hostaudit ALTER COLUMN scope TYPE varchar(255);",
	"ALTER TABLE hostaudit RENAME COLUMN \"user\" TO username;",
	"ALTER TABLE dhcpscope ALTER COLUMN text TYPE text;",
	"ALTER TABLE dhcpscope ALTER COLUMN export_file TYPE varchar(255);",
	"ALTER TABLE dhcpscope ALTER COLUMN failover_peer TYPE varchar(128);",
	"ALTER TABLE zone ALTER COLUMN include TYPE text;",
	"ALTER TABLE savedqueries ALTER COLUMN querytext TYPE text;",
	"ALTER TABLE accessright ALTER COLUMN object_id TYPE bigint;",
	"ALTER TABLE accessright ALTER COLUMN object_id SET NOT NULL;",
	"ALTER TABLE site ADD COLUMN gsf integer;",
	"ALTER TABLE site_history ADD COLUMN gsf integer;",
	);
}

# Change all table IDs and foreign keys to bigint (Ticket #737)
# Also, set them to NULLable and replace 0s with NULL values
# This allows us to apply foreign_key constraints and allow 
# user to fix their data before applying the NOT NULL constraints,
# which can be done later (see below)
my $meta = Netdot::Meta->new();
my @tables = $meta->get_tables(with_history=>1);

foreach my $mtable ( sort { $a->name cmp $b->name } @tables ){
    my $tname = lc($mtable->name);
    foreach my $mcol ( $mtable->get_columns ) {
        my $cname = $mcol->name;
        if ( $cname eq 'id' ){
            if ($netdot_config->get('DB_TYPE') eq "mysql") {
                push @statements, "ALTER TABLE $tname MODIFY COLUMN $cname bigint NOT NULL auto_increment;";
            } elsif ($netdot_config->get('DB_TYPE') eq "Pg") {
                push @statements, "ALTER TABLE $tname ALTER COLUMN $cname TYPE bigint;";
                push @statements, "ALTER TABLE $tname ALTER COLUMN $cname SET NOT NULL;";
            }
        } elsif ($cname eq 'info') {
            if ($netdot_config->get('DB_TYPE') eq "mysql") {
                push @statements, "ALTER TABLE $tname MODIFY COLUMN $cname text;";
            } elsif ($netdot_config->get('DB_TYPE') eq "Pg") {
                push @statements, "ALTER TABLE $tname ALTER COLUMN $cname TYPE text;";
            }
        }
        if ( $mcol->links_to ){
            if ($netdot_config->get('DB_TYPE') eq "mysql") {
                push @statements, "ALTER TABLE $tname MODIFY COLUMN $cname bigint;";
            } elsif ($netdot_config->get('DB_TYPE') eq "Pg") {
                push @statements, "ALTER TABLE $tname ALTER COLUMN $cname DROP NOT NULL;";
                push @statements, "ALTER TABLE $tname ALTER COLUMN $cname TYPE bigint;";
            }
            push @statements, "UPDATE $tname SET $cname=NULL WHERE $cname=0;";
        }
    }

    if ($netdot_config->get('DB_TYPE') eq "mysql") {
        push @statements, "ALTER TABLE $tname CONVERT TO CHARACTER SET utf8 COLLATE utf8_general_ci;";
    } 
}


# Update hostaudit with string data
#
foreach my $hid ( keys %haudit ){
    my ($zone, $scope) = ($haudit{$hid}{zone}, $haudit{$hid}{scope});
    next unless ($zone || $scope);
    my $st = 'UPDATE hostaudit SET';
    $st .= " zone='$zone'" if $zone;
    $st .= "," if ($zone && $scope);
    $st .= " scope='$scope'" if $scope;
    $st .= " WHERE id=$hid;";
    push @statements,  $st;
}

# Set version to 4 on current global DhcpScopes
push @statements, "UPDATE dhcpscope,dhcpscopetype SET dhcpscope.version=4 WHERE dhcpscopetype.name='global' AND dhcpscope.type=dhcpscopetype.id;";

# Add new DHCP attributes
push @statements, "INSERT INTO dhcpattrname (name) VALUES ('allow leasequery');",
push @statements, "INSERT INTO dhcpattrname (name) VALUES ('preferred-lifetime');",
push @statements, "INSERT INTO dhcpattrname (name) VALUES ('option dhcp6.name-servers');",
push @statements, "INSERT INTO dhcpattrname (name) VALUES ('option dhcp6.domain-search');",
push @statements, "INSERT INTO dhcpattrname (name) VALUES ('option dhcp6.preference');",
push @statements, "INSERT INTO dhcpattrname (name) VALUES ('option dhcp6.rapid-commit');",
push @statements, "INSERT INTO dhcpattrname (name) VALUES ('option dhcp6.info-refresh-time');",
push @statements, "INSERT INTO dhcpattrname (name) VALUES ('dhcpv6-lease-file-name');",
push @statements, "INSERT INTO dhcpattrname (name) VALUES ('range6');",
push @statements, "INSERT INTO dhcpattrname (name) VALUES ('prefix6');",

&processdata(\@statements);


##################   THIS HAS TO BE THE LAST THING   #######################
# Add FK constraints. 
my @schema = &generate_schema_from_metadata();
if ($netdot_config->get('DB_TYPE') eq "mysql") {
    @statements = ('SET foreign_key_checks=0;');
    my $fk_table;
    foreach ( @schema ){
        if ( /^CREATE TABLE `(\S+)`/ ){
            $fk_table = $1;
        }elsif ( /CONSTRAINT/ ){
            $_ =~ s/^\s+//; # Remove leading spaces
                $_ =~ s/,$//;   # Remove last comma
                push @statements, "ALTER TABLE $fk_table ADD $_;";
        }
    }
    push @statements, 'SET foreign_key_checks=1;';
} elsif ($netdot_config->get('DB_TYPE') eq "Pg") {
    @statements = ();
    foreach (0 .. $#schema ) { 
        if ( $schema[$_] =~  m/^ALTER TABLE "\S+" ADD FOREIGN KEY/ ) { 
            push @statements, $schema[$_] . $schema[$_ + 1];;
        }   
    }
}

&processdata(\@statements);

# Fix NOT NULL constraints
print "\n\n";
print '
This new version of Netdot fixes a number of lax database constraints. 
This means that table columns were previously defined in such a way that 
their values could be undefined (NULL) or zero when they should not. 

It is very likely that applying these constraints to your current schema now 
will fail because there are cases where columns were set to "NULL" or zero. 
You should try to apply these constraints now, and if they fail, you should 
fix your data and apply them again later.

Would you like to try applying these new "NOT NULL" constraints now? [y/N] ';
my $ans = <STDIN>;
if ( $ans =~ /^Y|y/ ){
    system('perl fix_not_null.pl');
}

&dbdisconnect();


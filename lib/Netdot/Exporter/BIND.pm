package Netdot::Exporter::BIND;

use base 'Netdot::Exporter';
use warnings;
use strict;
use Data::Dumper;

my $logger = Netdot->log->get_logger('Netdot::Exporter');
my $EOF_MARKER = "\n;#### EOF ####\n";

=head1 NAME

Netdot::Exporter::BIND - Read relevant info from Netdot and build BIND zone files

=head1 SYNOPSIS

    my $bind = Netdot::Exporter->new(type=>'BIND');
    $bind->generate_configs()

=head1 CLASS METHODS
=cut

############################################################################

=head2 new - Class constructor

  Arguments:
    None
  Returns:
    Netdot::Exporter::BIND object
  Examples:
    my $bind = Netdot::Exporter->new(type=>'BIND');
=cut

sub new{
    my ($class, %argv) = @_;
    my $self = {};

    bless $self, $class;
    return $self;
}

############################################################################

=head2 generate_configs - Generate zone files for BIND

  Arguments:
    Hashref with the following keys:
      zones  - Array ref.  List of zone names to export.
      nopriv - Exclude private data from zone file (TXT and HINFO)
  Returns:
    True if successful
  Examples:
    $bind->generate_configs();
=cut

sub generate_configs {
    my ($self, %argv) = @_;
    
    my @zones;
    
    if ( $argv{zones} ){
	unless ( ref($argv{zones}) eq 'ARRAY' ){
	    $self->throw_fatal("zones argument must be arrayref!");
	}
	foreach my $name ( @{$argv{zones}} ){
	    if ( Zone->search(name=>$name) ){
		push @zones, Zone->search(name=>$name)->first;
	    }else{
		$self->throw_user("Zone $name not found");
	    }
	}
    }elsif ( $argv{zone_ids} ){
	unless ( ref($argv{zone_ids}) eq 'ARRAY' ){
	    $self->throw_fatal("zone_ids argument must be arrayref!");
	}
	foreach my $id ( @{$argv{zone_ids}} ){
	    if ( my $zone = Zone->retrieve($id) ){
		push @zones, $zone;
	    }else{
		$self->throw_user("Zone $id not found");
	    }
	}

    }else{
	@zones = Zone->retrieve_all();
    }
   
    foreach my $zone ( @zones ){
	unless ( $zone->active ){
	    $logger->debug(sprintf("Zone %s marked as inactive. Skipping.", $zone->name));
	    next;
	}
	# Determine if we need to export or not
	my $do_gen = 0;
	if ( $argv{force} ){
	    $do_gen = 1; # We're told to force the export
	}else{
	    # Check if the resulting zone will be different
	    my $text = $self->generate_zone(zone=>$zone, nopriv=>$argv{nopriv});
	    if ( $zone->digest && ($self->sha_digest($text) eq $zone->digest) ){
		$logger->debug(sprintf("Exporter::BIND::generate_configs: %s has".
				       " no pending changes.  Use -f to force.",
				       $zone->name));
	    }else{
		# Zone has changed
		$do_gen = 1;
	    }
	}
	if ( $do_gen ){
	    eval {
		Netdot::Model->do_transaction(sub{
		    $zone->update_serial();
		    # Unfortunately we need to generate the content again with a new serial
		    my $text = $self->generate_zone(zone=>$zone, nopriv=>$argv{nopriv});
		    $zone->update({digest=>$self->sha_digest($text)});
		    my $path = $self->print_to_file(zone=>$zone, text=>$text);
		    $logger->info(sprintf("Zone %s written to file: %s", $zone->name, $path));
					      });
	    };
	    $logger->error($@) if $@;
	}
    }
}

############################################################################

=head2 generate_zone -  Generate the zone file using BIND syntax

  Args: 
    Hash with:
    zone - Zone object
    nopriv - Exclude TXT and HINFO records
  Returns: 
    Zone text (string)
  Examples:
    my $text = $bind->generate_zone(zone=>$zone, nopriv=>1);

=cut

sub generate_zone {
    my ($self, %argv) = @_;

    my $zone = $argv{zone} || $self->throw_fatal("Missing required argument: zone");

    # Make sure that there's an Apex and NS records
    my $apex = RR->search(name=>'@', zone=>$zone)->first 
    	|| $self->throw_user(sprintf("Zone %s: Apex record (@) not defined", $zone->name));

    $self->throw_user(sprintf("Zone %s has no NS records", $zone->name))
	unless $apex->ns_records();
    
    my $start = time;
    my $rec = $zone->get_all_records();

    my $text = "; Generated by Netdot -- http://netdot.uoregon.edu \n\n";

    # Print the default TTL
    $text .= 'TTL '.$zone->default_ttl."\n" if defined $zone->default_ttl;

    # Print the SOA record
    $text .= $zone->soa_string."\n";

    foreach my $name ( sort { $rec->{$a}->{order} <=> $rec->{$b}->{order} } keys %$rec ){
	foreach my $type ( qw/A AAAA TXT HINFO NS DS MX CNAME PTR NAPTR SRV LOC/ ){
	    if ( defined $rec->{$name}->{$type} ){
		# Special cases.  These are relatively rare and harder to print.
		if ( $type =~ /^(LOC|SRV|NAPTR)$/ ){
		    my $rrclass = 'RR'.$type;
		    foreach my $id ( sort keys %{$rec->{$name}->{$type}->{id}} ){
			my $rr = $rrclass->retrieve($id);
			$text .= $rr->as_text."\n";
		    }
		}else{
		    foreach my $data ( sort keys %{$rec->{$name}->{$type}} ){
			if ( $argv{nopriv} && $type eq 'HINFO' ){
			    next;
			}
			my $ttl = $rec->{$name}->{$type}->{$data};
			if ( !defined $ttl || $ttl !~ /\d+/ ){
			    $logger->debug("$name $type: TTL not defined or invalid. Using Zone default");
			    $ttl = $zone->default_ttl;
			}
			if ( $type =~ /^(MX|NS|CNAME|PTR)$/ ){
			    # Add the final dot if necessary
			    $data .= '.' unless $data =~ /\.$/;
			}

			my $line = "$name\t$ttl\tIN\t$type\t$data\n";

			if ( $argv{nopriv} && $type eq 'TXT' ){
			    # We're told to exclude TXT records
			    # Allow exceptions from config
			    if ( my @patterns = @{$self->config->get('TXT_RECORD_EXCEPTIONS')} ){
				foreach my $pattern ( @patterns ){
				    if ( $line =~ /$pattern/ ){
					$text .= $line;
					last;
				    }
				}
			    }
			}else{
			    $text .= $line;
			}
		    }
		}
	    }
	}
    }

    # Add any includes
    $text .= $zone->include."\n" if defined $zone->include;
    $text .= $EOF_MARKER;
    $logger->debug(sprintf("Zone %s generated in %s", 
			   $zone->name, $self->sec2dhms(time-$start)));

    return $text;
}

############################################################################

=head2 print_to_file

  Args: 
    Hash with following keys:
      zone - Zone object
      text - Zone contents (string)
  Returns: 
    Path of file written to
  Examples:
    my $path = $bind->print_to_file($content);

=cut

sub print_to_file {
    my ($self, %argv) = @_;

    $self->throw_fatal("Missing required arguments")
	unless ($argv{zone} && $argv{text});

    my $zone = $argv{zone};

    $self->throw_fatal("Zone contents do not contain EOF marker")
	unless $argv{text} =~ /$EOF_MARKER/;

    my $dir = Netdot->config->get('BIND_EXPORT_DIR') 
	|| $self->throw_user('BIND_EXPORT_DIR not defined in config file!');
    
    my $filename = $zone->export_file;
    unless ( $filename ){
	$logger->warn('Export filename not defined for this zone: '. $zone->name.' Using zone name.');
	$filename = $zone->name;
    }
    my $path = "$dir/$filename";
    my $fh = $self->open_and_lock($path);
    print $fh $argv{text};
    close($fh);
    return $path;
}

=head1 AUTHOR

Carlos Vicente, C<< <cvicente at ns.uoregon.edu> >>
Dongting Yu, C<< <dongting at ns.uoregon.edu> >>

=head1 COPYRIGHT & LICENSE

Copyright 2012 University of Oregon, all rights reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

=cut

#Be sure to return 1
1;
